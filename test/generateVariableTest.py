vars = (
    # 1. C++ name
    # 2. C++ init
    # 3. Python value
    ('None', 'std::static_pointer_cast<GenericVariable>(std::make_shared<NoneVariable>())', None),
    ('None2', 'std::static_pointer_cast<GenericVariable>(std::make_shared<NoneVariable>())', None),
    ('False', 'VAR(Bool, false)', False),
    ('False2', 'VAR(Bool, false)', False),
    ('True', 'VAR(Bool, true)', True),
    ('True2', 'VAR(Bool, true)', True),
    ('IntZero', 'VAR(Int, 0)', 0),
    ('IntOne', 'VAR(Int, 1)', 1),
    ('IntTwo', 'VAR(Int, 2)', 2),
    ('IntTwo2', 'VAR(Int, 2)', 2),
    ('Int8', 'VAR(Int, 8)', 8),
    ('IntMinusOne', 'VAR(Int, -1)', -1),
    ('IntMinusOne2', 'VAR(Int, -1)', -1),
    ('IntMinus12', 'VAR(Int, -12)', -12),
    ('IntMinus73', 'VAR(Int, -73)', -73),
    ('FloatMinusOne', 'VAR(Float, -1)', -1.0),
    ('FloatZero', 'VAR(Float, 0)', 0.0),
    ('FloatOne', 'VAR(Float, 1)', 1.0),
    ('FloatTwo', 'VAR(Float, 2)', 2.0),
    ('FloatTwo2', 'VAR(Float, 2)', 2.0),
    ('Float2_5', 'VAR(Float, 2.5)', 2.5),
    ('Float_23_74', 'VAR(Float, -23.74)', -23.74),
    ('StrEmpty', 'VAR(String, "")', ''),
    ('StrEmpty2', 'VAR(String, "")', ''),
    ('StrA', 'VAR(String, "some text")', 'some text'),
    ('StrA2', 'VAR(String, "some text")', 'some text'),
    ('StrB', 'VAR(String, "other text")', 'other text'),
)

# TODO: % is an operator for string formatting
# Does it mean that % operation is indeed defined for strings as formatting?

header = r"""
#include "variable/Variable.h"

#include "Test.h"

#define VAR(TYPE, VALUE) \
    std::static_pointer_cast<GenericVariable>(std::make_shared<TYPE ## Variable>(VALUE))

"""

for v in vars:
    header += "static auto " + v[0] + " = " + v[1] + ";\n"


def generate_for_arithmetic_operation(operation, cpp_name, fh):
    global vars

    for v1 in vars:
        for v2 in vars:
            try:
                res = eval('v1[2] ' + operation + 'v2[2]')

                _type = str(type(res)).replace("<class '", "").replace("'>", "")
                if _type == "str":
                    _type = "string"
                    res = '"' + res + '"'
                elif _type == "complex":
                    # Complex numbers not implemented
                    continue

                print("    CHECK_VAR(" + v1[0] + "->" + cpp_name + "(" + v2[0] + "), " + _type.upper() + ", " + _type.capitalize() + ", " + str(res) + ");", file=fh)
            except:
                print("    MUST_THROW(" + v1[0] + "->" + cpp_name + "(" + v2[0] + "));", file=fh)


ops = (
    ("+", "add"),
    ("-", "sub"),
    ("*", "mul"),
    ("/", "div"),
    ("//", "int_div"),
    ("**", "pow"),
    ("%", "mod"),
)

funcs = []

for o in ops:
    funcs.append("test_variable_" + o[1])

    with open("Autogenerated/test_variable_" + o[1] + ".cpp", "w") as f:
        print(header, file=f)
        print("void test_variable_" + o[1] + "() {", file=f)
        generate_for_arithmetic_operation(o[0], o[1], f)
        print("}", file=f)

ops2 = (
    ("==", "equal"),
    ("<", "less"),
)

for o in ops2:
    funcs.append("test_variable_" + o[1])

    with open("Autogenerated/test_variable_" + o[1] + ".cpp", "w") as f:
        print(header, file=f)
        print("void test_variable_" + o[1] + "() {", file=f)

        for v1 in vars:
            for v2 in vars:
                try:
                    isNot = "" if eval('v1[2] ' + o[0] + 'v2[2]') else "!"
                    print("    MY_ASSERT(" + isNot + v1[0] + "->" + o[1] + "(" + v2[0] + "));", file=f)
                except:
                    print("    MUST_THROW(" + v1[0] + "->" + o[1] + "(" + v2[0] + "));", file=f)

        print("}", file=f)

with open("Autogenerated/test_variable_to_bool.cpp", "w") as f:
    print(header, file=f)
    print("void test_variable_to_bool () {", file=f)
    
    for v in vars:
        isNot = "" if v[2] else "!"
        print("    MY_ASSERT(" + isNot + v[0] + "->to_bool());", file=f)

    print("}", file=f)

    funcs.append('test_variable_to_bool')


with open("Autogenerated/test_variable.cpp", "w") as f:
    for func in funcs:
        print("extern void " + func + "();", file=f)

    print("void test_variable() {", file=f)

    for func in funcs:
        print("    " + func + "();", file=f)

    print("}", file=f)
