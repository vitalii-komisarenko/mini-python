vars = (
    # 1. C++ name
    # 2. C++ init
    # 3. Python value
    ('None', 'std::static_pointer_cast<GenericVariable>(std::make_shared<NoneVariable>())', None),
    ('None2', 'std::static_pointer_cast<GenericVariable>(std::make_shared<NoneVariable>())', None),
    ('False', 'VAR(Bool, false)', False),
    ('False2', 'VAR(Bool, false)', False),
    ('True', 'VAR(Bool, true)', True),
    ('True2', 'VAR(Bool, true)', True),
    ('IntZero', 'VAR(Int, 0)', 0),
    ('IntOne', 'VAR(Int, 1)', 1),
    ('IntTwo', 'VAR(Int, 2)', 2),
    ('IntTwo2', 'VAR(Int, 2)', 2),
    ('Int8', 'VAR(Int, 8)', 8),
    ('IntMinusOne', 'VAR(Int, -1)', -1),
    ('IntMinusOne2', 'VAR(Int, -1)', -1),
    ('IntMinus12', 'VAR(Int, -12)', -12),
    ('IntMinus73', 'VAR(Int, -73)', -73),
    ('FloatMinusOne', 'VAR(Float, -1)', -1.0),
    ('FloatZero', 'VAR(Float, 0)', 0.0),
    ('FloatOne', 'VAR(Float, 1)', 1.0),
    ('FloatTwo', 'VAR(Float, 2)', 2.0),
    ('FloatTwo2', 'VAR(Float, 2)', 2.0),
    ('Float2_5', 'VAR(Float, 2.5)', 2.5),
    ('Float_23_74', 'VAR(Float, -23.74)', -23.74),
    ('StrEmpty', 'VAR(String, "")', ''),
    ('StrEmpty2', 'VAR(String, "")', ''),
    ('StrA', 'VAR(String, "some text")', 'some text'),
    ('StrA2', 'VAR(String, "some text")', 'some text'),
    ('StrB', 'VAR(String, "other text")', 'other text'),
    ('ListEmpty', 'VAR(List, ListVariable::ListType())', []),
    ('ListEmpty2', 'VAR(List, ListVariable::ListType())', []),
)

# TODO: % is an operator for string formatting
# Does it mean that % operation is indeed defined for strings as formatting?

header = r"""
#include "variable/Variable.h"

#include "Test.h"

#define VAR(TYPE, VALUE) \
    std::static_pointer_cast<GenericVariable>(std::make_shared<TYPE ## Variable>(VALUE))

enum class BinaryOp {
    add,
    sub,
    mul,
    div,
    int_div,
    pow,
    mod,
};

enum class AssertResult {
    PASS,
    FAIL,
    EXCEPTION,
};

static std::ostream& operator<< (std::ostream& os, AssertResult res) {
    switch (res) {
    case AssertResult::PASS:       os << "PASS";      break;
    case AssertResult::FAIL:       os << "FAIL";      break;
    case AssertResult::EXCEPTION:  os << "EXCEPTION"; break;
    default:                       os << "???";
    }
    return os;
}

static Variable doBinaryOp(Variable arg1, Variable arg2, BinaryOp op) {
    switch(op) {
    case BinaryOp::add: return arg1->add(arg2);
    case BinaryOp::sub: return arg1->sub(arg2);
    case BinaryOp::mul: return arg1->mul(arg2);
    case BinaryOp::div: return arg1->div(arg2);
    case BinaryOp::int_div: return arg1->int_div(arg2);
    case BinaryOp::mod: return arg1->mod(arg2);
    case BinaryOp::pow: return arg1->pow(arg2);
    default: throw std::runtime_error("Bad op");
    }
}

static AssertResult doBinaryOpAndCompareResult(Variable arg1, Variable arg2, BinaryOp op, Variable expected_res) {
    try {
        auto res = doBinaryOp(arg1, arg2, op);
        return res->strictly_equal(expected_res) ? AssertResult::PASS : AssertResult::FAIL;
    }
    catch(...) {
        return AssertResult::EXCEPTION;
    }
}

"""

for v in vars:
    header += "static auto " + v[0] + " = " + v[1] + ";\n"


def generate_for_arithmetic_operation(operation, cpp_name, fh):
    global vars

    for v1 in vars:
        for v2 in vars:
            assert_result = "PASS"
            _type = "None"
            res = ""
            try:
                res = eval('v1[2] ' + operation + 'v2[2]')

            except:
                assert_result = "EXCEPTION"

            _type = str(type(res)).replace("<class '", "").replace("'>", "")
            res_str = ""

            if _type == "None":
                res_str = "None"
            if _type == "str":
                _type = "string"
                res = '"' + res + '"'
            elif _type == "complex":
                # Complex numbers not implemented
                continue
            elif _type == 'list':
                # Only empty lists supported in tests
                res_str = 'VAR(List, ListVariable::ListType())'

            if not res_str:
                res_str = "VAR(" + _type.capitalize() + ", " + str(res) + ")"

            print("    MY_ASSERT_EQUAL(doBinaryOpAndCompareResult(" + v1[0] + ", " + v2[0] + ", BinaryOp::" + cpp_name + ", " + res_str + "), AssertResult::" + assert_result + ");", file=fh)


ops = (
    ("+", "add"),
    ("-", "sub"),
    ("*", "mul"),
    ("/", "div"),
    ("//", "int_div"),
    ("**", "pow"),
    ("%", "mod"),
)

funcs = []

for o in ops:
    funcs.append("test_variable_" + o[1])

    with open("Autogenerated/test_variable_" + o[1] + ".cpp", "w") as f:
        print(header, file=f)
        print("void test_variable_" + o[1] + "() {", file=f)
        generate_for_arithmetic_operation(o[0], o[1], f)
        print("}", file=f)

ops2 = (
    ("==", "equal"),
    ("<", "less"),
)

for o in ops2:
    funcs.append("test_variable_" + o[1])

    with open("Autogenerated/test_variable_" + o[1] + ".cpp", "w") as f:
        print(header, file=f)
        print("void test_variable_" + o[1] + "() {", file=f)

        for v1 in vars:
            for v2 in vars:
                try:
                    isNot = "" if eval('v1[2] ' + o[0] + 'v2[2]') else "!"
                    print("    MY_ASSERT(" + isNot + v1[0] + "->" + o[1] + "(" + v2[0] + "));", file=f)
                except:
                    print("    MUST_THROW(" + v1[0] + "->" + o[1] + "(" + v2[0] + "));", file=f)

        print("}", file=f)

with open("Autogenerated/test_variable_to_bool.cpp", "w") as f:
    print(header, file=f)
    print("void test_variable_to_bool () {", file=f)

    for v in vars:
        isNot = "" if v[2] else "!"
        print("    MY_ASSERT(" + isNot + v[0] + "->to_bool());", file=f)

    print("}", file=f)

    funcs.append('test_variable_to_bool')


with open("Autogenerated/test_variable.cpp", "w") as f:
    for func in funcs:
        print("extern void " + func + "();", file=f)

    print("void test_variable() {", file=f)

    for func in funcs:
        print("    " + func + "();", file=f)

    print("}", file=f)
